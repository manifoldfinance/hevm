<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>hevm</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="book.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="overview.html">Quick Overview</a></li><li class="chapter-item affix "><li class="part-title">Tutorials</li><li class="chapter-item "><a href="dstest-tutorial.html">DSTest-based Testing</a></li><li class="chapter-item "><a href="equivalence-checking.html">Equivalence checking</a></li><li class="chapter-item affix "><li class="part-title">Reference</li><li class="chapter-item "><a href="test.html">DSTest-base Testing</a></li><li class="chapter-item "><a href="symbolic.html">Symbolic unit execution</a></li><li class="chapter-item "><a href="equivalence.html">Equivalence checking</a></li><li class="chapter-item "><a href="exec.html">Concrete execution</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">hevm</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ethereum/hevm" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>The hevm project is an implementation of the Ethereum Virtual Machine (EVM) focused on symbolic analysis of evm bytecode. This essentially means that hevm can try out <em>all</em> execution possibilities of your contract and see it can somehow violate some assertions you have, such as e.g. the total number of tokens must always be X or that some value must never be greater than Y.</p>
<p>In some sense, hevm is similar to a fuzzer, but instead of only trying with random values to trigger faults, it instead <em>computes</em> whether a fault is possible. If it is possible, it gives an example call to trigger the fault, and if it isn't possible, it mathematically proves it so, and tells the user the contract is safe. Note that while great pains have gone into making sure hevm's results can be trusted, there can always be bugs in hevm or the libraries and tools it uses.</p>
<p>Hevm can not only be used to find bugs in already written programs, but can also help you write a program that from the outside behaves the same as the original program, but may use less gas to execute. This can be done via (equivalence checking)[#equivalence-checking] where hevm will either prove that the behaviour of the two bytecodes is the same, or will give inputs where they differ.</p>
<h2 id="practical-scenario"><a class="header" href="#practical-scenario">Practical scenario</a></h2>
<p>The following is a practical scenario involving a smart contract function designed to transfer money under certain conditions, namely that no balance can be larger than or equal to 100. Let's see the contract and its associated check:</p>
<pre><code class="language-solidity">// SPDX-License-Identifier: MIT

pragma solidity ^0.8.19;
import "ds-test/test.sol";

contract MyContract is DSTest {
  mapping (address =&gt; uint) balances;
  function prove_add_value(address recv, uint amt) public {
    require(balances[recv] &lt; 100);
    if (balances[recv] + amt &gt; 100) {
      revert();
    }
    balances[recv] += amt;
    assert(balances[recv] &lt; 100);
  }
}
</code></pre>
<p>Notice that this function has a bug: the <code>require</code> and the <code>assert</code> both check for <code>&lt;</code>, but the <code>if</code> checks for <code>&gt;</code>, which should instead be <code>&gt;=</code>. Let's see if <code>hevm</code> can find this bug. In order to do that, we have to prepend the function name with <code>prove_</code>, which we did.</p>
<h3 id="building"><a class="header" href="#building">Building</a></h3>
<p>We now need a copy of hevm (see <a href="https://github.com/ethereum/hevm/releases">releases</a>) and the SMT solver z3, which can be installed e.g. with <code>apt-get</code> on ubuntu/debian or <code>homebrew</code> on Mac, and a copy of <a href="https://getfoundry.sh/">Foundry</a>:</p>
<pre><code class="language-shell">$ sudo apt-get install z3  # install z3
$ curl -L https://foundry.paradigm.xyz | bash # install foundryup
$ foundryup # install forge and other foundry binaries
$ mkdir mytest &amp;&amp; cd mytest
$ wget https://github.com/ethereum/hevm/releases/download/release/0.53.0/hevm-x86_64-linux
$ chmod +x ./hevm-x86_64-linux
$ forge init .
$ cat &lt;&lt;EOF &gt; src/contract.sol
pragma solidity ^0.8.19;
import "ds-test/test.sol";

contract MyContract is DSTest {
  mapping (address =&gt; uint) balances;
  function prove_add_value(address recv, uint amt) public {
    require(balances[recv] &lt; 100);
    if (balances[recv] + amt &gt; 100) {
      revert();
    }
    balances[recv] += amt;
    assert(balances[recv] &lt; 100);
  }
}
EOF
$ forge build
[⠊] Compiling...
[⠒] Compiling 1 files with 0.8.19
[⠢] Solc 0.8.19 finished in 14.27ms
Compiler run successful!
</code></pre>
<h3 id="finding-the-bug"><a class="header" href="#finding-the-bug">Finding the Bug</a></h3>
<p>Now let's run <code>hevm</code> to see if it finds the bug:</p>
<pre><code class="language-shell">$ hevm test --solver z3
Running 1 tests for src/contract.sol:MyContract
[FAIL] prove_add_value(address,uint256)
  Counterexample:
    result:   Revert: 0x4e487b710000000000000000000000000000000000000000000000000000000000000001
    calldata: prove_add_value(0x0000000000000000000000000000000000000000,100)
</code></pre>
<h3 id="fixing-the-bug"><a class="header" href="#fixing-the-bug">Fixing the Bug</a></h3>
<p>This counterexample tells us that when sending exactly 100 to an empty account, the new balance will violate the <code>&lt; 100</code> assumption. Let's fix this bug, the new <code>prove_add_value</code> should now say:</p>
<pre><code class="language-solidity">  function prove_add_value(address recv, uint amt) public {
    require(balances[recv] &lt; 100);
    if (balances[recv] + amt &gt;= 100) {
      revert();
    }
    balances[recv] += amt;
    assert(balances[recv] &lt; 100);
  }
</code></pre>
<p>Let's re-build with forge and check with hevm once again:</p>
<pre><code class="language-shell">$ forge build
[⠰] Compiling...
[⠔] Compiling 1 files with 0.8.19
[⠒] Solc 0.8.19 finished in 985.32ms
Compiler run successful!
</code></pre>
<pre><code class="language-shell">$ hevm test --solver z3
Running 1 tests for src/contract.sol:MyContract
[PASS] prove_add_value(address,uint256)
</code></pre>
<p>We now get a <code>PASS</code>. Notice that this doesn't only mean that hevm couldn't find a bug within a given time frame. Instead, it means that there is surely no call to <code>prove_add_value</code> such that our assertion can be violated. However, it <em>does not</em> check for things that it was not asked to check for. In particular, it does not check that e.g. the sender's balance is decremented. There is no such test and so this omission is not detected.</p>
<h2 id="capabilities"><a class="header" href="#capabilities">Capabilities</a></h2>
<ul>
<li>Symbolic execution of solidity tests written using <a href="https://github.com/dapphub/ds-test/"><code>ds-test</code></a> (a.k.a "foundry tests"). This allows one to find <em>all</em> potential failure modes of a function.</li>
<li>Fetch remote state via RPC, so your tests can be rooted in the real-world, calling out to other, existing contracts, with existing state and already deployed bytecode.</li>
<li>Prove equivalence of two different bytecode objects such as two functions or even entire contracts.</li>
</ul>
<h2 id="similarities-and-differences-to-other-tools"><a class="header" href="#similarities-and-differences-to-other-tools">Similarities and Differences to Other Tools</a></h2>
<p>Hevm is similar to <a href="https://github.com/a16z/halmos">Halmos</a> and <a href="https://docs.runtimeverification.com/kontrol/overview/readme">Kontrol</a> in its approach.</p>
<p>However, it is quite different from static code analysis tools such as <a href="https://github.com/enzymefinance/oyente">Oyente</a>, <a href="https://github.com/crytic/slither">Slither</a>, and <a href="https://github.com/ConsenSys/mythril">Mythril</a>. While these 3 tools typically use some form of symbolic execution to try to validate their results, their main method of operation is not via symbolic execution, and they can, and do, report false positives.</p>
<p>Notice that static code analysis tools will find bugs that the author(s) didn't write a test case for, as they typically have a (large) set of preconfigured test-cases that they will report on, if they can find a way to violate them. In that sense, it may be valuable to run them alongside hevm.</p>
<p>Finally, <a href="https://github.com/ethereum/solidity/blob/develop/docs/smtchecker.rst">SMTChecker</a> may also be interesting to run alongside hevm. SMTChecker is very different from both approaches detailed above. While SMTChecker is capable of reliably finding both reentrancy and loop-related bugs, the tools above can only do so on a best effort basis. Hevm often reports a warning of incompleteness for such problems, while static code analysis tools either report potential positives or may even not discover them at all.</p>
<h3 id="comparison-table"><a class="header" href="#comparison-table">Comparison Table</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Tool</th><th>Approach</th><th>Primary Method</th><th>Notes</th></tr></thead><tbody>
<tr><td><strong>hevm</strong></td><td>Symbolic analysis of EVM bytecode</td><td>Symbolic execution</td><td>Focuses on exploring all execution possibilities, identifying potential assertion violations, and optimizing gas usage. Can prove equivalence between bytecodes.</td></tr>
<tr><td><strong>Halmos</strong></td><td>Similar to hevm</td><td>Not specified</td><td>Approach similar to hevm, but the document does not detail specific methodologies or differences.</td></tr>
<tr><td><strong>Kontrol</strong></td><td>Similar to hevm</td><td>Not specified</td><td>Approach similar to hevm, with a focus presumably on symbolic analysis as well, but further details are not provided in the document.</td></tr>
<tr><td><strong>Oyente</strong></td><td>Static code analysis</td><td>Partial symbolic execution</td><td>Uses symbolic execution to validate results but primarily relies on static analysis. Can report false positives.</td></tr>
<tr><td><strong>Slither</strong></td><td>Static code analysis</td><td>Partial symbolic execution</td><td>Similar to Oyente, uses static analysis as its main method, complemented by symbolic execution for validation. Known for reporting false positives.</td></tr>
<tr><td><strong>Mythril</strong></td><td>Static code analysis</td><td>Partial symbolic execution</td><td>Combines static code analysis with symbolic execution for result validation. Like Oyente and Slither, can report false positives.</td></tr>
<tr><td><strong>SMTChecker</strong></td><td>Different from both hevm and static code analysis tools</td><td>SMT solving</td><td>Capable of finding reentrancy and loop-related bugs reliably, which other tools might miss or report incompletely. Offers a distinct approach from symbolic execution.</td></tr>
</tbody></table>
</div>
<h2 id="history"><a class="header" href="#history">History</a></h2>
<p>Hevm was originally developed as part of the <a href="https://github.com/dapphub/dapptools/">dapptools</a> project, and was forked into this repo by the Formal Verification team at the Ethereum Foundation in August 2022.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="controlling-the-unit-testing-environment"><a class="header" href="#controlling-the-unit-testing-environment">Controlling the Unit Testing Environment</a></h1>
<h2 id="writing-tests"><a class="header" href="#writing-tests">Writing Tests</a></h2>
<p>Test cases must be prepended with <code>prove_</code> and the testing contract must inherit from <code>Test</code> from (Foundry's standard test library)[https://book.getfoundry.sh/forge/forge-std]. First, import Test: <code>import {Test} from "forge-std/Test.sol";</code> and then inherit from it via <code>... is Test</code>. This allows hevm to discover the test cases it needs to run. Like so:</p>
<pre><code class="language-solidity">pragma solidity ^0.8.19;
import {Test} from "forge-std/Test.sol";
contract BadVaultTest is Test {
  function prove_mytest() {
  // environment setup, preconditions
  // call(s) to test
  // postcondition checks
  }
}
</code></pre>
<p>Once you have written such a test case, you need to compile with <code>forge build</code> (see <a href="https://book.getfoundry.sh/forge/tests">forge documentation</a> for more details) and then:</p>
<pre><code>$ hevm test
Checking 1 function(s) in contract src/badvault-test.sol:BadVault
[RUNNING] prove_mytest(uint256)
   [PASS] prove_mytest(uint256)
</code></pre>
<p>Here, hevm discovered the test case, and automatically checked it for violations.</p>
<h2 id="setting-up-tests"><a class="header" href="#setting-up-tests">Setting Up Tests</a></h2>
<p>Tests usually need to set up the environment in a particular way, such as contract address, storage, etc. This can be done via Cheat Codes that can change the address of the caller, set block number, etc. See <a href="dstest-tutorial.html#supported-cheat-codes">Cheat Codes</a> below for a range of cheat codes supported. Cheat Codes are a standard method used by other tools, such as <a href="https://book.getfoundry.sh/">Foundry</a>, so you should be able to re-use your existing setup. An example setup could be:</p>
<pre><code class="language-solidity">pragma solidity ^0.8.19;
import {Test} from "forge-std/Test.sol";
contract BadVaultTest is Test {
    MyVault vault;

    function setUp() public {
        // Set up environment
        vault = new BadVault();

        address user1 = address(1);
        vm.deal(user1, 1 ether);
        vm.prank(user1);
        vault.deposit{value: 1 ether}();

        address user2 = address(2);
        vm.deal(user2, 1 ether);
        vm.prank(user2);
        vault.deposit{value: 1 ether}();

        address attacker = address(42);
        vm.prank(attacker);
        // call(s) to test
        // postcondition checks
    }
}
</code></pre>
<p>The postconditions should check the state of the contract after the call(s) are complete. In particular, it should check that the changes that the function applied did not break any of the (invariants)[https://en.wikipedia.org/wiki/Invariant_(mathematics)] of the contract, such as total number of tokens.</p>
<p>You can read more about testing and cheat codes in the (Foundy Book)[https://book.getfoundry.sh/forge/cheatcodes]. Below are the cheat codes that hevm supports.</p>
<h2 id="understanding-counterexamples"><a class="header" href="#understanding-counterexamples">Understanding Counterexamples</a></h2>
<p>When hevm discovers a failure, it prints an example call how to trigger the failure. Let's see the following simple solidity code:</p>
<pre><code>pragma solidity ^0.8.19;
import {Test} from "forge-std/Test.sol";
contract MyContract is Test {
  mapping (address =&gt; uint) balances;
  function prove_single_fail(address recv, uint amt) public {
    require(balances[recv] &lt; 100);
    if (balances[recv] + amt &gt; 100) { revert(); }
    balances[recv] += amt;
    assert(balances[recv] &lt; 100);
  }
}
</code></pre>
<p>After compiling with <code>forge build</code>, when ran under hevm, we get:</p>
<pre><code>$ hevm test
Checking 1 function(s) in contract src/contract-fail.sol:MyContract
[RUNNING] prove_single_fail(address,uint256)
   [FAIL] prove_single_fail(address,uint256)
   Counterexample:
     result:   Revert: 0x4e487b710000000000000000000000000000000000000000000000000000000000000001
     calldata: prove_single_fail(0x0000000000000000000000000000000000000000,100)
</code></pre>
<p>Here, hevm provided us with a calldata, where the receiver happens to be the zero address, and the value sent is exactly 100. This indeed is the boundary condition where the function call fails. The function should have had a <code>&gt;=</code> rather than a <code>&gt;</code> in the <code>if</code>. Notice that in this case, while hevm filled in the <code>address</code> to give a complete call, the address itself is irrelevant, although this is not explicitly mentioned.</p>
<h2 id="test-cases-that-must-always-revert"><a class="header" href="#test-cases-that-must-always-revert">Test Cases that Must Always Revert</a></h2>
<p>Hevm assumes that a test case should not always revert. If you have such a test case, Hevm will warn you and return a FAIL. For example this toy contract:</p>
<pre><code class="language-solidity">pragma solidity ^0.8.19;
import {Test} from "forge-std/Test.sol";
contract MyContract is Test {
  uint256 cntr;
  function prove_allrevert(uint256 val) public {
      if(val &lt; 0) {
          unchecked { cntr = val; }
          revert();
      } else revert();
  }
}
</code></pre>
<p>When compiled with forge and then ran under hevm with <code>hevm test</code>, hevm returns:</p>
<pre><code>Checking 1 function(s) in contract src/contract-allrevert.sol:MyContract
[RUNNING] prove_allrevert(uint256)
   [FAIL] prove_allrevert(uint256)
   Reason:
     No reachable assertion violations, but all branches reverted
     Prefix this testname with `proveFail` if this is expected
</code></pre>
<p>This is sometimes undesirable. In these cases, prefix your contract with <code>proveFail_</code> instead of <code>prove_</code>:</p>
<pre><code class="language-solidity">pragma solidity ^0.8.19;
import {Test} from "forge-std/Test.sol";
contract MyContract is Test {
  uint256 cntr;
  function proveFail_allrevert_expected(uint256 val) public {
      if(val &lt; 0) {
          unchecked {
            cntr = val;
            cntr += 1;
          }
          revert();
      }
      else revert();
  }
}
</code></pre>
<p>When this is compiled with forge and then checked with hevm, it leads to:</p>
<pre><code>Checking 1 function(s) in contract src/contract-allrevert-expected.sol:MyContract
[RUNNING] proveFail_allrevert_expected(uint256)
   [PASS] proveFail_allrevert_expected(uint256)
</code></pre>
<p>Which is now the expected outcome.</p>
<h2 id="supported-cheat-codes"><a class="header" href="#supported-cheat-codes">Supported Cheat Codes</a></h2>
<p>Since hevm is an EVM implementation mainly dedicated to testing and exploration, it features a set of <code>cheat codes</code> which can manipulate the environment in which the execution is run. These can be accessed by calling into a contract (typically called <code>Vm</code>) at address <code>0x7109709ECfa91a80626fF3989D68f67F5b1DD12D</code>, which implements the following methods</p>
<ul>
<li>
<p><code>function prank(address sender) public</code> Sets <code>msg.sender</code> to the specified <code>sender</code> for the next call.</p>
</li>
<li>
<p><code>function deal(uint usr, uint amt) public</code> Sets the eth balance of <code>usr</code> to <code>amt</code>. Note that if <code>usr</code> is a symbolic address, then it must be the address of a contract that has already been deployed. This restriction is in place to ensure soundness of our symbolic address encoding with respect to potential aliasing of symbolic addresses.</p>
</li>
<li>
<p><code>function store(address c, bytes32 loc, bytes32 val) public</code> Sets the slot <code>loc</code> of contract <code>c</code> to <code>val</code>.</p>
</li>
<li>
<p><code>function warp(uint x) public</code> Sets the block timestamp to <code>x</code>.</p>
</li>
<li>
<p><code>function roll(uint x) public</code> Sets the block number to <code>x</code>.</p>
</li>
<li>
<p><code>function assume(bool b) public</code> Add the condition <code>b</code> to the assumption base for the current branch. This functions almost identically to <code>require</code>.</p>
</li>
<li>
<p><code>function load(address c, bytes32 loc) public returns (bytes32 val)</code> Reads the slot <code>loc</code> of contract <code>c</code>.</p>
</li>
<li>
<p><code>function sign(uint sk, bytes32 digest) public returns (uint8 v, bytes32 r, bytes32 s)</code> Signs the <code>digest</code> using the private key <code>sk</code>. Note that signatures produced via <code>hevm.sign</code> will leak the private key.</p>
</li>
<li>
<p><code>function addr(uint sk) public returns (address addr)</code> Derives an ethereum address from the private key <code>sk</code>. Note that <code>hevm.addr(0)</code> will fail with <code>BadCheatCode</code> as <code>0</code> is an invalid ECDSA private key.</p>
</li>
<li>
<p><code>function ffi(string[] calldata) external returns (bytes memory)</code> Executes the arguments as a command in the system shell and returns stdout. Expects abi encoded values to be returned from the shell or an error will be thrown. Note that this cheatcode means test authors can execute arbitrary code on user machines as part of a call to <code>dapp test</code>, for this reason all calls to <code>ffi</code> will fail unless the <code>--ffi</code> flag is passed.</p>
</li>
<li>
<p><code>function createFork(string calldata urlOrAlias) external returns (uint256)</code> Creates a new fork with the given endpoint and the <em>latest</em> block and returns the identifier of the fork.</p>
</li>
<li>
<p><code>function selectFork(uint256 forkId) external</code> Takes a fork identifier created by <code>createFork</code> and sets the corresponding forked state as active.</p>
</li>
<li>
<p><code>function activeFork() external returns (uint256)</code> Returns the identifier of the current fork.</p>
</li>
<li>
<p><code>function label(address addr, string calldata label) external</code> Labels the address in traces</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="equivalence-checking"><a class="header" href="#equivalence-checking">Equivalence Checking</a></h1>
<p>Equivalence checking enables the comparison of two bytecodes determine if they perform the same actions under all possible input conditions. This process, for example, allows for the creation of two functions: one that is verified to be reliable, and another that consumes less gas, but whose correctness is challenging to ascertain. Through equivalence checking, it is possible to ascertain whether the two functions exhibit identical behavior.</p>
<h2 id="finding-discrepancies"><a class="header" href="#finding-discrepancies">Finding Discrepancies</a></h2>
<p>Let's see this toy contract, in file <code>contract1.sol</code>:</p>
<pre><code class="language-solidity">//SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;
contract MyContract {
  mapping (address =&gt; uint) balances;
  function my_adder(address recv, uint amt) public {
    if (balances[recv] + amt &gt;= 100) { revert(); }
    balances[recv] += amt;
  }
}
</code></pre>
<p>And this, slightly modified one, in file <code>contract2.sol</code>:</p>
<pre><code class="language-solidity">//SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;
contract MyContract {
  mapping (address =&gt; uint) balances;
  function my_adder(address recv, uint amt) public {
    if (balances[recv] + amt &gt;= 100) { revert(); }
    balances[recv] += amt/2;
    balances[recv] += amt/2;
  }
}
</code></pre>
<p>Now ask hevm if they are equivalent. First, let's compile both contracts and get their bytecode</p>
<pre><code class="language-shell">bytecode1=$(solc --bin-runtime "contract1.sol" | tail -n1)
bytecode2=$(solc --bin-runtime "contract2.sol" | tail -n1)
</code></pre>
<p>Let's ask hevm to compare the two:</p>
<pre><code class="language-shell">$ cabal run exe:hevm -- equivalence \
      --code-a $(solc --bin-runtime "contract1.sol" | tail -n1) \
      --code-b $(solc --bin-runtime "contract2.sol" | tail -n1)

  Found 90 total pairs of endstates
  Asking the SMT solver for 58 pairs
  Reuse of previous queries was Useful in 0 cases
  Not equivalent. The following inputs result in differing behaviours:
  -----
  Calldata:
    0xafc2c94900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000023
  Storage:
    Addr SymAddr "entrypoint": [(0x0,0x10)]
  Transaction Context:
    TxValue: 0x0
</code></pre>
<p>This tells us that with a value of 0x23 being sent, which corresponds to 35, the two are not equivalent. This is indeed the case: one will add <code>35 div 2 = 17</code> twice, which is 34, the other will add 35.</p>
<h2 id="fixing-and-proving-correctness"><a class="header" href="#fixing-and-proving-correctness">Fixing and Proving Correctness</a></h2>
<p>Let's fix the above issue by incrementing the balance by 1 in case it's an odd value. Let's call this <code>contract3.sol</code>:</p>
<pre><code class="language-solidity">//SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;
contract MyContract {
  mapping (address =&gt; uint) balances;
  function my_adder(address recv, uint amt) public {
    if (balances[recv] + amt &gt;= 100) { revert(); }
    balances[recv] += amt/2;
    balances[recv] += amt/2;
    if (amt % 2 != 0) balances[recv]++;
  }
}
</code></pre>
<p>Let's check whether this new contract is indeed equivalent:</p>
<pre><code class="language-shell">$ cabal run exe:hevm -- equivalence \
    --code-a $(solc --bin-runtime "contract1.sol" | tail -n1) \
    --code-b $(solc --bin-runtime "contract3.sol" | tail -n1)

  Found 108 total pairs of endstates
  Asking the SMT solver for 74 pairs
  Reuse of previous queries was Useful in 0 cases
  No discrepancies found
</code></pre>
<p>Hevm reports that the two are now equivalent, even though they clearly don't consume the same amount of gas and have widely different EVM bytecode. Yet for an outside observer, they behave the same. Notice that hevm didn't simply fuzz the contract and within a given out of time it didn't find a counterexample. Instead, it <em>proved</em> the two equivalent from an outside observer perspective.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hevm-test"><a class="header" href="#hevm-test"><code>hevm test</code></a></h1>
<pre><code>Usage: hevm test [--root STRING] [--project-type PROJECTTYPE] [--rpc TEXT]
                 [--number W256] [--verbose INT] [--coverage] [--match STRING]
                 [--solver TEXT] [--num-solvers NATURAL] [--smtdebug] [--debug]
                 [--trace] [--ffi] [--smttimeout NATURAL]
                 [--max-iterations INTEGER]
                 [--loop-detection-heuristic LOOPHEURISTIC]
                 [--abstract-arithmetic] [--abstract-memory]
                 [--num-cex-fuzz INTEGER] [--ask-smt-iterations INTEGER]

Available options:
  -h,--help                Show this help text
  --root STRING            Path to project root directory (default: . )
  --project-type PROJECTTYPE
                           Is this a Foundry or DappTools project (default:
                           Foundry)
  --rpc TEXT               Fetch state from a remote node
  --number W256            Block: number
  --verbose INT            Append call trace: {1} failures {2} all
  --coverage               Coverage analysis
  --match STRING           Test case filter - only run methods matching regex
  --solver TEXT            Used SMT solver: z3 (default), cvc5, or bitwuzla
  --num-solvers NATURAL    Number of solver instances to use (default: number of
                           cpu cores)
  --smtdebug               Print smt queries sent to the solver
  --debug                  Debug printing of internal behaviour
  --trace                  Dump trace
  --ffi                    Allow the usage of the hevm.ffi() cheatcode (WARNING:
                           this allows test authors to execute arbitrary code on
                           your machine)
  --smttimeout NATURAL     Timeout given to SMT solver in seconds (default: 300)
  --max-iterations INTEGER Number of times we may revisit a particular branching
                           point
  --loop-detection-heuristic LOOPHEURISTIC
                           Which heuristic should be used to determine if we are
                           in a loop: StackBased (default) or Naive
                           (default: StackBased)
  --abstract-arithmetic    Use abstraction-refinement for complicated arithmetic
                           functions such as MulMod. This runs the solver first
                           with abstraction turned on, and if it returns a
                           potential counterexample, the counterexample is
                           refined to make sure it is a counterexample for the
                           actual (not the abstracted) problem
  --abstract-memory        Use abstraction-refinement for Memory. This runs the
                           solver first with abstraction turned on, and if it
                           returns a potential counterexample, the
                           counterexample is refined to make sure it is a
                           counterexample for the actual (not the abstracted)
                           problem
  --num-cex-fuzz INTEGER   Number of fuzzing tries to do to generate a
                           counterexample (default: 3) (default: 3)
  --ask-smt-iterations INTEGER
                           Number of times we may revisit a particular branching
                           point before we consult the smt solver to check
                           reachability (default: 1) (default: 1)
</code></pre>
<p><code>hevm test</code> executes all solidity unit tests that make use of the <code>DSTest</code> assertion library (a.k.a "Foundry tests"). It supports both foundry based (the default) and dapptools based projects.</p>
<p>It has support for:</p>
<ul>
<li>unit tests (<code>test</code> prefix, no arguments)</li>
<li>fuzz tests (<code>test</code> prefix, with function arguments)</li>
<li>invariant tests (<code>invariant</code> prefix, with function arguments)</li>
<li>symbolic tests (<code>prove</code> prefix, with function arguments)</li>
</ul>
<p>A more detailed introduction to symbolic unit tests with <code>hevm</code> can be found <a href="https://fv.ethereum.org/2020/12/11/symbolic-execution-with-ds-test/">here</a>. An overview of using ds-test for solidity testing can be found in the <a href="https://book.getfoundry.sh/forge/tests">foundry book</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hevm-symbolic"><a class="header" href="#hevm-symbolic"><code>hevm symbolic</code></a></h1>
<pre><code class="language-sh">Usage: hevm symbolic [--code TEXT] [--calldata TEXT] [--address ADDR]
                     [--caller ADDR] [--origin ADDR] [--coinbase ADDR]
                     [--value W256] [--nonce WORD64] [--gas WORD64]
                     [--number W256] [--timestamp W256] [--basefee W256]
                     [--priority-fee W256] [--gaslimit WORD64] [--gasprice W256]
                     [--create] [--maxcodesize W256] [--prev-randao W256]
                     [--chainid W256] [--rpc TEXT] [--block W256]
                     [--root STRING] [--project-type PROJECTTYPE]
                     [--initial-storage INITIALSTORAGE] [--sig TEXT]
                     [--arg STRING]... [--get-models] [--show-tree]
                     [--show-reachable-tree] [--smttimeout NATURAL]
                     [--max-iterations INTEGER] [--solver TEXT] [--smtdebug]
                     [--assertions [WORD256]] [--ask-smt-iterations INTEGER]
                     [--num-solvers NATURAL]
                     [--loop-detection-heuristic LOOPHEURISTIC]

Available options:
  -h,--help                Show this help text
  --code TEXT              Program bytecode
  --calldata TEXT          Tx: calldata
  --address ADDR           Tx: address
  --caller ADDR            Tx: caller
  --origin ADDR            Tx: origin
  --coinbase ADDR          Block: coinbase
  --value W256             Tx: Eth amount
  --nonce WORD64           Nonce of origin
  --gas WORD64             Tx: gas amount
  --number W256            Block: number
  --timestamp W256         Block: timestamp
  --basefee W256           Block: base fee
  --priority-fee W256      Tx: priority fee
  --gaslimit WORD64        Tx: gas limit
  --gasprice W256          Tx: gas price
  --create                 Tx: creation
  --maxcodesize W256       Block: max code size
  --prev-randao W256       Block: prevRandao
  --chainid W256           Env: chainId
  --rpc TEXT               Fetch state from a remote node
  --block W256             Block state is be fetched from
  --root STRING            Path to project root directory (default: . )
  --project-type PROJECTTYPE
                           Is this a Foundry or DappTools project (default:
                           Foundry)
  --initial-storage INITIALSTORAGE
                           Starting state for storage: Empty, Abstract (default
                           Abstract)
  --sig TEXT               Signature of types to decode / encode
  --arg STRING             Values to encode
  --get-models             Print example testcase for each execution path
  --show-tree              Print branches explored in tree view
  --show-reachable-tree    Print only reachable branches explored in tree view
  --smttimeout NATURAL     Timeout given to SMT solver in seconds (default: 300)
  --max-iterations INTEGER Number of times we may revisit a particular branching
                           point
  --solver TEXT            Used SMT solver: z3 (default), cvc5, or bitwuzla
  --smtdebug               Print smt queries sent to the solver
  --assertions [WORD256]   Comma separated list of solc panic codes to check for
                           (default: user defined assertion violations only)
  --ask-smt-iterations INTEGER
                           Number of times we may revisit a particular branching
                           point before we consult the smt solver to check
                           reachability (default: 1) (default: 1)
  --num-solvers NATURAL    Number of solver instances to use (default: number of
                           cpu cores)
  --loop-detection-heuristic LOOPHEURISTIC
                           Which heuristic should be used to determine if we are
                           in a loop: StackBased (default) or Naive
                           (default: StackBased)
</code></pre>
<p>Run a symbolic execution against the given parameters, searching for assertion violations.</p>
<p>Counterexamples will be returned for any reachable assertion violations. Where an assertion violation is defined as either an execution of the invalid opcode (<code>0xfe</code>), or a revert with a message of the form <code>abi.encodeWithSelector('Panic(uint256)', errCode)</code> with <code>errCode</code> being one of the predefined solc assertion codes defined <a href="https://docs.soliditylang.org/en/latest/control-structures.html#panic-via-assert-and-error-via-require">here</a>.</p>
<p>By default hevm ignores assertion violations that result from arithmetic overflow (<code>Panic(0x11)</code>), although this behaviour can be customised via the <code>--assertions</code> flag. For example, the following will return counterexamples for arithmetic overflow (<code>0x11</code>) and user defined assertions (<code>0x01</code>):</p>
<pre><code>hevm symbolic --code $CODE --assertions '[0x01, 0x11]'
</code></pre>
<p>The default value for <code>calldata</code> and <code>caller</code> are symbolic values, but can be specialized to concrete functions with their corresponding flags.</p>
<p>One can also specialize specific arguments to a function signature, while leaving others abstract. If <code>--sig</code> is given, calldata is assumed to be of the form suggested by the function signature. With this flag, specific arguments can be instantiated to concrete values via the <code>--arg</code> flag.</p>
<p>This is best illustrated through a few examples:</p>
<p>Calldata specialized to the bytestring <code>0xa9059cbb</code> followed by 64 symbolic bytes:</p>
<pre><code class="language-sh">hevm symbolic --sig "transfer(address,uint256)" --code $(&lt;dstoken.bin-runtime)
</code></pre>
<p>Calldata specialized to the bytestring <code>0xa9059cbb0000000000000000000000007cfa93148b0b13d88c1dce8880bd4e175fb0dedf</code> followed by 32 symbolic bytes.</p>
<pre><code class="language-sh">hevm symbolic --sig "transfer(address,uint256)" --arg 0x7cFA93148B0B13d88c1DcE8880bd4e175fb0DeDF --code $(&lt;dstoken.bin-runtime)
</code></pre>
<p>Calldata specialized to the bytestring <code>0xa9059cbb</code> followed by 32 symbolic bytes, followed by the bytestring <code>0000000000000000000000000000000000000000000000000000000000000000</code>:</p>
<pre><code class="language-sh">hevm symbolic --sig "transfer(address,uint256)" --arg "&lt;symbolic&gt;" --arg 0 --code $(&lt;dstoken.bin-runtime)
</code></pre>
<p>If the <code>--get-models</code> flag is given, example input values will be returned for each possible execution path. This can be useful for automatic test case generation.</p>
<p>The default timeout for SMT queries is no timeout. If your program is taking longer than a couple of minutes to run, you can experiment with configuring the timeout to somewhere around 10s by doing <code>--smttimeout 10000</code></p>
<p>Storage can be initialized in two ways:</p>
<ul>
<li><code>Empty</code>: all storage slots for all contracts are initialized to zero</li>
<li><code>Abstract</code>: all storage slots are initialized as unconstrained abstract values</li>
</ul>
<p><code>hevm</code> uses an eager approach for symbolic execution, meaning that it will first attempt to explore all branches in the program (without querying the smt solver to check if they are reachable or not). Once the full execution tree has been explored, the postcondition is checked against all leaves, and the solver is invoked to check reachability for branches where a postcondition violation could occur. While our tests have shown this approach to be significantly faster, when applied without limits it would always result in infinite exploration of code involving loops, so after some predefined number of iterations (controlled by the <code>--ask-smt-iterations</code> flag), the solver will be invoked to check whether a given loop branch is reachable. In cases where the number of loop iterations is known in advance, you may be able to speed up execution by setting this flag to an appropriate value.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hevm-equivalence"><a class="header" href="#hevm-equivalence"><code>hevm equivalence</code></a></h1>
<pre><code>Usage: hevm equivalence --code-a TEXT --code-b TEXT [--sig TEXT]
                        [--arg STRING]... [--calldata TEXT]
                        [--smttimeout NATURAL] [--max-iterations INTEGER]
                        [--solver TEXT] [--smtoutput] [--smtdebug] [--debug]
                        [--trace] [--ask-smt-iterations INTEGER]
                        [--num-cex-fuzz INTEGER]
                        [--loop-detection-heuristic LOOPHEURISTIC]
                        [--abstract-arithmetic] [--abstract-memory]

Available options:
  -h,--help                Show this help text
  --code-a TEXT            Bytecode of the first program
  --code-b TEXT            Bytecode of the second program
  --sig TEXT               Signature of types to decode / encode
  --arg STRING             Values to encode
  --calldata TEXT          Tx: calldata
  --smttimeout NATURAL     Timeout given to SMT solver in seconds (default: 300)
  --max-iterations INTEGER Number of times we may revisit a particular branching
                           point
  --solver TEXT            Used SMT solver: z3 (default), cvc5, or bitwuzla
  --smtoutput              Print verbose smt output
  --smtdebug               Print smt queries sent to the solver
  --debug                  Debug printing of internal behaviour
  --trace                  Dump trace
  --ask-smt-iterations INTEGER
                           Number of times we may revisit a particular branching
                           point before we consult the smt solver to check
                           reachability (default: 1) (default: 1)
  --num-cex-fuzz INTEGER   Number of fuzzing tries to do to generate a
                           counterexample (default: 3) (default: 3)
  --loop-detection-heuristic LOOPHEURISTIC
                           Which heuristic should be used to determine if we are
                           in a loop: StackBased (default) or Naive
                           (default: StackBased)
  --abstract-arithmetic    Use abstraction-refinement for complicated arithmetic
                           functions such as MulMod. This runs the solver first
                           with abstraction turned on, and if it returns a
                           potential counterexample, the counterexample is
                           refined to make sure it is a counterexample for the
                           actual (not the abstracted) problem
  --abstract-memory        Use abstraction-refinement for Memory. This runs the
                           solver first with abstraction turned on, and if it
                           returns a potential counterexample, the
                           counterexample is refined to make sure it is a
                           counterexample for the actual (not the abstracted)
                           problem
</code></pre>
<p>Symbolically execute both the code given in <code>--code-a</code> and <code>--code-b</code> and try to prove equivalence between their outputs and storages.</p>
<p>If <code>--sig</code> is given, calldata is assumed to take the form of the function given. If left out, calldata is a fully abstract buffer of at most 256 bytes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hevm-exec"><a class="header" href="#hevm-exec"><code>hevm exec</code></a></h1>
<p>Run an EVM computation using specified parameters, using an interactive debugger when <code>--debug</code> flag is given.</p>
<pre><code>Usage: hevm exec [--code TEXT] [--calldata TEXT] [--address ADDR]
                 [--caller ADDR] [--origin ADDR] [--coinbase ADDR]
                 [--value W256] [--nonce WORD64] [--gas WORD64] [--number W256]
                 [--timestamp W256] [--basefee W256] [--priority-fee W256]
                 [--gaslimit WORD64] [--gasprice W256] [--create]
                 [--maxcodesize W256] [--prev-randao W256] [--chainid W256]
                 [--debug] [--trace] [--rpc TEXT] [--block W256] [--root STRING]
                 [--project-type PROJECTTYPE]

Available options:
  -h,--help                Show this help text
  --code TEXT              Program bytecode
  --calldata TEXT          Tx: calldata
  --address ADDR           Tx: address
  --caller ADDR            Tx: caller
  --origin ADDR            Tx: origin
  --coinbase ADDR          Block: coinbase
  --value W256             Tx: Eth amount
  --nonce WORD64           Nonce of origin
  --gas WORD64             Tx: gas amount
  --number W256            Block: number
  --timestamp W256         Block: timestamp
  --basefee W256           Block: base fee
  --priority-fee W256      Tx: priority fee
  --gaslimit WORD64        Tx: gas limit
  --gasprice W256          Tx: gas price
  --create                 Tx: creation
  --maxcodesize W256       Block: max code size
  --prev-randao W256       Block: prevRandao
  --chainid W256           Env: chainId
  --debug                  Debug printing of internal behaviour
  --trace                  Dump trace
  --rpc TEXT               Fetch state from a remote node
  --block W256             Block state is be fetched from
  --root STRING            Path to project root directory (default: . )
  --project-type PROJECTTYPE
                           Is this a Foundry or DappTools project (default:
                           Foundry)
</code></pre>
<p>Minimum required flags: either you must provide <code>--code</code> or you must both pass <code>--rpc</code> and <code>--address</code>. If the execution returns an output, it will be written to stdout. Exit code indicates whether the execution was successful or errored/reverted.</p>
<p>Simple example usage:</p>
<pre><code>hevm exec --code 0x647175696e6550383480393834f3 --gas 0xff
"Return: 0x647175696e6550383480393834f3"
</code></pre>
<p>Which says that given the EVM bytecode <code>0x647175696e6550383480393834f3</code>, the Ethereum Virtual Machine will put <code>0x647175696e6550383480393834f3</code> in the RETURNDATA.</p>
<p>To execute a mainnet transaction:</p>
<pre><code># install seth as per https://github.com/makerdao/developerguides/blob/master/devtools/seth/seth-guide/seth-guide.md
$ export ETH_RPC_URL=https://mainnet.infura.io/v3/YOUR_API_KEY_HERE
$ export TXHASH=0xd2235b9554e51e8ff5b3de62039d5ab6e591164b593d892e42b2ffe0e3e4e426
hevm exec --caller $(seth tx $TXHASH from) --address $(seth tx $TXHASH to) --calldata $(seth tx $TXHASH input) --rpc $ETH_RPC_URL --block $(($(seth tx $TXHASH blockNumber)-1)) --gas $(seth tx $TXHASH gas)
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="solidity.min.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
